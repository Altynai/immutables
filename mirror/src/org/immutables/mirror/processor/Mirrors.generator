[template generate]
  [for model in allMirrors]
[output.java model.package (model.name 'Mirror')]
[generateMirror model]
[/output.java]
  [/for]
[/template]

[template generateMirror MirrorModel m]
package [m.package];

import javax.lang.model.element.*;
import javax.lang.model.type.*;
import javax.lang.model.util.*;
import com.google.common.base.Preconditions;
import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;

/**
 * [m.name]Mirror used to parse data of AnnotationMirror for annotation {@value #ANNOTATION_NAME}
 * during annotation processing. Interface is being described using {@link [m.name]} annotation,
 * which should be structurally compatible to the annotation being modelled.
 * @see #find(Iterable)
 * @see #from(AnnotationMirror)
 */
@SuppressWarnings("all")
public class [m.name]Mirror implements [m.name] {
  public static final String ANNOTATION_NAME = "[m.annotationTypeCommas]".replace(',', '.');

  /**
   * Finds first annotation of this type in an iterable of annotation mirrors.
   * @param mirrors annotation mirrors
   * @return optional {@code [m.name]Mirror}, present if this annotation found
   */
  public static Optional<[m.name]Mirror> find(Iterable<? extends AnnotationMirror> mirrors) {
    for (AnnotationMirror mirror : mirrors) {
      TypeElement element = (TypeElement) mirror.getAnnotationType().asElement();
      if (element.getQualifiedName().contentEquals(ANNOTATION_NAME)) {
        return Optional.of(new [m.name]Mirror(mirror));
      }
    }
    return Optional.absent();
  }

  /**
   * Converts iterable of annotation mirrors where all annotation are of this type. Otherwise it fails
   * @param mirrors of this annotation type.
   * @return list of converted {@code [m.name]Mirror}s
   */
  public static ImmutableList<[m.name]Mirror> fromAll(Iterable<? extends AnnotationMirror> mirrors) {
    ImmutableList.Builder<[m.name]Mirror> builder = ImmutableList.builder();
    for (AnnotationMirror mirror : mirrors) {
      TypeElement element = (TypeElement) mirror.getAnnotationType().asElement();
      Preconditions.checkState(element.getQualifiedName().contentEquals(ANNOTATION_NAME),
          "Supplied mirrors should all be of this annotation type");
      builder.add(new [m.name]Mirror(mirror));
    }
    return builder.build();
  }

  /**
   * Tries to convert annotation mirror to this annotation type.
   * @param mirror annotation mirror
   * @return optional {@code [m.name]Mirror}, present if mirror matched this annotation type
   */
  public static Optional<[m.name]Mirror> from(AnnotationMirror mirror) {
    return find(java.util.Collections.singleton(mirror));
  }

  private final AnnotationMirror mirror;
[for a in m.attributes]
  private final [targetAttributeType a][a.suffix] [a.name];
  [if a.kind.type]
  private final String[a.suffix] [a.name]Name;
  [/if]
[/for]

  private [m.name]Mirror(AnnotationMirror mirror) {
    this.mirror = mirror;

  [if m.attributes]
  [for a in m.attributes]
    [if a.kind.type]
    TypeMirror[a.suffix] [a.name] = null;
    String[a.suffix] [a.name]Name = null;
    [else if a.kind.annotation]
    AnnotationMirror[a.suffix] [a.name] = null;
    [else if a.kind.primitive]
    [a.type][a.suffix] [a.name] = [if a.boolean]false[else]0[/if];
    [else]
    [a.type][a.suffix] [a.name] = null;
    [/if]
  [/for]

    java.util.Map<? extends ExecutableElement, ? extends AnnotationValue> attributeValues = mirror.getElementValues();
    for (ExecutableElement attributeElement
        : ElementFilter.methodsIn(mirror.getAnnotationType().asElement().getEnclosedElements())) {
      String name = attributeElement.getSimpleName().toString();
      [for a in m.attributes]
      if ("[a.name]".equals(name)) {
        AnnotationValue annotationValue = attributeValues.get(attributeElement);
        if (annotationValue == null) {
          annotationValue = attributeElement.getDefaultValue();
        }
        if (annotationValue == null) {
          throw new IllegalStateException("Annotation mirror contains no value (neither default) for '[a.name]' attribute of @" + ANNOTATION_NAME);
        }
        [toUpper a.name]Extractor [a.name]Extractor = new [toUpper a.name]Extractor();
        annotationValue.accept([a.name]Extractor, null);

          [if a.kind.type]
        [a.name] = [a.name]Extractor.get();
        [a.name]Name = [a.name]Extractor.name();
          [else if a.kind.annotation]
        [a.name] = [a.name]Extractor.get();
          [else]
        [a.name] = [a.name]Extractor.get();
          [/if]
        continue;
      }
      [/for]
    }
    [for a in m.attributes]
      [if a.kind.type]
    this.[a.name] = Preconditions.checkNotNull([a.name]);
    this.[a.name]Name = Preconditions.checkNotNull([a.name]Name);
      [else if a.kind.annotation]
    this.[a.name] = Preconditions.checkNotNull([a.name]);
      [else if a.kind.primitive]
    this.[a.name] = [a.name];
      [else]
    this.[a.name] = Preconditions.checkNotNull([a.name]);
      [/if]
    [/for]
  [/if]
  }
[for a in m.attributes]
  [if a.kind.type]

  /**
   * @return type name for value of attribute {@code [a.name]}
   */
  public String[a.suffix] [a.name]Name() {
    return [a.name]Name[if a.array].clone()[/if];
  }

  /**
   * @return type mirror for value of attribute {@code [a.name]}
   */
  public [targetAttributeType a][a.suffix] [a.name]Mirror() {
    return [a.name][if a.array].clone()[/if];
  }

  /**
   * @deprecated Always throws UnsupportedOperationException. Use {@link #[a.name]Mirror} or {@link [a.name]Name}.
   */
  @Deprecated
  @Override
  public [a.type][a.suffix] [a.name]() {
    throw new UnsupportedOperationException("Use '[a.name]Mirror()' or '[a.name]Name()'");
  }
  [else if a.kind.annotation]

  /**
   * @return annotation mirror for value of attribute {@code [a.name]}
   */
  public [targetAttributeType a][a.suffix] [a.name]Mirror() {
    return [a.name][if a.array].clone()[/if];
  }

  /**
   * @deprecated Always throws UnsupportedOperationException. Use {@link #[a.name]Mirror()}.
   */
  @Deprecated
  @Override
  public [a.type][a.suffix] [a.name]() {
    throw new UnsupportedOperationException("Use '[a.name]Mirror()' to get to the annotation value");
  }
  [else]

  /**
   * @return value of attribute {@code [a.name]}
   */
  @Override
  public [a.type][a.suffix] [a.name]() {
    return [a.name][if a.array].clone()[/if];
  }
  [/if]
[/for]

  /**
   * @return underlying annotation mirror
   */
  public AnnotationMirror getMirror() {
    return mirror;
  }

  /**
   * @return {@code [m.name].class}
   */
  public Class<? extends java.lang.annotation.Annotation> annotationType() {
    return [m.name].class;
  }

[for a in m.attributes]
  [attributeExtractor a]
[/for]
}
[/template]

[template attributeExtractor AttributeModel a]
[let brackets]['[]'][/let]
[let targetType][targetAttributeType a][/let]

private static class [toUpper a.name]Extractor extends SimpleAnnotationValueVisitor7<Void, Void> {
[if a.array]
  [targetType][brackets] values;
  int position;

  @Override
    [if a.kind.type]
  public Void visitType(TypeMirror value, Void p) {
    this.values['[']position++[']'] = value;
    [else if a.kind.enum]
  public Void visitEnumConstant(VariableElement value, Void p) {
    this.values['[']position++[']'] = [a.type].valueOf(value.getSimpleName().toString());
    [else if a.kind.annotation]
  public Void visitAnnotation(AnnotationMirror value, Void p) {
    this.values['[']position++[']'] = value;
    [else if a.kind.string]
  public Void visitString(String value, Void p) {
    this.values['[']position++[']'] = value;
    [else]
  public Void visit[toUpper targetType]([targetType] value, Void p) {
    this.values['[']position++[']'] = value;
    [/if]
    return null;
  }

  @Override
  public Void visitArray(java.util.List<? extends AnnotationValue> array, Void p) {
    this.values = new [targetType]['[']array.size()[']'];
    com.google.common.base.Verify.verify(position == 0);
    for (AnnotationValue value : array) {
      value.accept(this, null);
    }
    return null;
  }

  [targetType][brackets] get() {
    return values;
  }
  [if a.kind.type]

  public String[brackets] name() {
    String[brackets] names = new String['[']values.length[']'];
    for (int i = 0; i < values.length; i++) {
      names['[i]'] = values['[i]'].toString();
    }
    return names;
  }
  [/if]
[else]
  [targetType] value;

  @Override
    [if a.kind.type]
  public Void visitType(TypeMirror value, Void p) {
    this.value = value;
    [else if a.kind.enum]
  public Void visitEnumConstant(VariableElement value, Void p) {
    this.value = [a.type].valueOf(value.getSimpleName().toString());
    [else if a.kind.annotation]
  public Void visitAnnotation(AnnotationMirror value, Void p) {
    this.value = value;
    [else if a.kind.string]
  public Void visitString(String value, Void p) {
    this.value = value;
    [else]
  public Void visit[toUpper targetType]([targetType] value, Void p) {
    this.value = value;
    [/if]
    return null;
  }

  @Override
  public Void visitArray(java.util.List<? extends AnnotationValue> array, Void p) {
    Preconditions.checkState(!array.isEmpty());
    array.get(0).accept(this, null);
    return null;
  }
  [if a.kind.type]

  public String name() {
    return value.toString();
  }
  [/if]

  [targetType] get() {
    return value;
  }
[/if]

  @Override
  protected Void defaultAction(Object o, Void p) {
    throw new IllegalStateException("Incompatible annotation content of attribute '[a.name]' in @" + ANNOTATION_NAME);
  }
}
[/template]

[template targetAttributeType AttributeModel a][output.trim]
  [if a.kind.type]
    TypeMirror
  [else if a.kind.annotation]
    AnnotationMirror
  [else]
    [a.type]
  [/if]
[/output.trim][/template]
