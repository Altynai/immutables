[template generate Type type]
[output.java type.packageName type.defName]
  [if type.emptyNesting]
[generateImmutableNestingType type]
  [else]
[generateImmutableSimpleType type]
  [/if]
[/output.java]
[/template]

[template generateImmutableNestingType Type type]
[if type.packageName]
package [type.packageName];
[/if]

/**
 * {@code [type.defName]} contains immutable implementation classes generated from
 * abstract value types defined as nested inside {@link [type.name]}.
[for v in type.nestedChildren]
 * @see [v.immutableReferenceName]
[/for]
 */
@SuppressWarnings("all")
@javax.annotation.ParametersAreNonnullByDefault
@javax.annotation.Generated({"Immutables.generator", "[type.name]"})
[type.accessPrefix]final class [type.defName] {
  private [type.defName]() {}
[for v in type.nestedChildren]
  [generateImmutableType v 'static ']
[/for]
}
[/template]

[template generateImmutableSimpleType Type type]
[if type.packageName]
package [type.packageName];
[/if]

[generateImmutableType type '']
[/template]

[template generateImmutableType Type type String classModifiers]

[for setters = type.settableAttributes]
/**
 * Immutable implementation of {@link [type.name]}.
 * <p>
 * Use static factory methods to create instances: {@code of()} or
 * {@code builder()}.
 */
@SuppressWarnings("all")
@javax.annotation.ParametersAreNonnullByDefault
@javax.annotation.Generated({"immutable.tjs", "[type.name]"})
@javax.annotation.concurrent.Immutable
[type.accessPrefix][classModifiers]final class [type.defName]
    [type.inheritsKeyword] [type.name] {
[if type.useSingleton]

  private static final [type.defName] INSTANCE = checkPreconditions(new [type.defName]());

  /**
   * Returns default immutable singleton value of [type.defName]
   * @return immutable instance of [type.name]
   */
  public static [type.defName] of() {
    return INSTANCE;
  }
[/if]
[if type.useInterned or type.generateOrdinalValue]

  private static class InternProxy {
    final [type.defName] instance;

    InternProxy([type.defName] instance) {
      this.instance = instance;
    }

    public boolean equals(Object another) {
      return instance.equalTo(((InternProxy) another).instance);
    }

    public int hashCode() {
      return instance.computeHashCode();
    }
  }
[/if]
[if type.generateOrdinalValue]

  /**
   * Copy constructor used for interning of objects implementing
   * {@link org.immutables.common.collect.OrdinalValue}
   */
  private [type.defName]([type.defName] instance, int ordinal) {
  [for v in type.implementedAttributes]
    this.[v.name] = instance.[v.name];
  [/for]
  [if type.usePrehashed]
    this.hashCode = instance.hashCode;
  [/if]
    this.domain = instance.domain;
    this.ordinal = ordinal;
  }

  /**
   * Instances of {@code [type.defName]} will be interned and registered with the domain.
   */
  public static final class Domain
      extends org.immutables.common.collect.internal.InterningOrdinalDomain<InternProxy, [type.name]> {

    private static final Domain INSTANCE = new Domain();

    /** Construct ordinal domain of [type.name] values. */
    public Domain() {
    }

    protected [type.name] extractValue(InternProxy proxy, int ordinal) {
      return new [type.defName](proxy.instance, ordinal);
    }
    @Override
    public String toString() {
      if (this == INSTANCE) {
        return "[type.defName].Domain.get()";
      }
      return com.google.common.base.MoreObjects.toStringHelper("[type.defName].Domain")
        .add("length", length())
        .toString();
    }

    /**
     * Gets static singleton instance of {@link OrdinalDomain}.
     * All instances that was not build with specified domain will be bound to static domain.
     * @return ordinal domain of all instances
     */
    public static Domain get() {
      return INSTANCE;
    }
  }

  @Override
  public org.immutables.common.collect.OrdinalDomain<[type.name]> domain() {
    return domain;
  }

  private static [type.defName] intern([type.defName] instance) {
    return ([type.defName]) instance.domain.internOrdinal(new InternProxy(instance));
  }
[else if type.useInterned]

  private static final com.google.common.collect.Interner<InternProxy> INTERNER = com.google.common.collect.Interners.newStrongInterner();

  private static [type.defName] intern([type.defName] instance) {
    return INTERNER.intern(new InternProxy(instance)).instance;
  }
[/if]
[if type.useConstructor]

  /**
   * Constructs new immutable instance of [type.name].
[for v in type.constructorArguments]
   * @param [v.name] value for {@code [v.name]}
[/for]
   * @return immutable [type.name] instance
   */
  public static [type.defName] of([for v in type.constructorArguments][if not for.first], [/if][v.type] [v.name][/for]) {
    return checkPreconditions(new [type.defName]([for v in type.constructorArguments][if not for.first], [/if][v.name][/for]));
  }
[/if]

  private static [type.defName] checkPreconditions([type.defName] instance) {
[if type.validationMethodName]
    instance.[type.validationMethodName]();
[/if]
[if type.useInterned or type.generateOrdinalValue]
    instance = intern(instance);
[/if]
    return instance;
  }
[generateImmutable type]
[if type.useBuilder]

  /**
   * Creates builder for {@link [type.name]}.
   * @return new [type.name] builder
   */
  public static Builder builder() {
    return new Builder();
  }
  [generateBuilder type]
[/if]
[generateLazyValues type]
[if type.hasNestedChildren]
[for v in type.nestedChildren]
  [generateImmutableType  v 'static ']
[/for]
[/if]
}
[/for]
[/template]

[template generateLazyValues Type type]
[for l in type.lazyAttributes]
  [if for.first]
  @javax.annotation.concurrent.GuardedBy("this")
  private volatile int lazyBitmap;
  [/if]

  [let maskConstantName][toConstant l.name]_LAZILY_INITIALIZED_BIT[/let]
  private static final int [maskConstantName] = 1 << [for.index];

  @javax.annotation.concurrent.GuardedBy("this")
  private [l.type] [l.name];

  @Override
  public [l.type] [l.name]() {
    if ((lazyBitmap & [maskConstantName]) == 0) {
      synchronized (this) {
        if ((lazyBitmap & [maskConstantName]) == 0) {
            [if l.primitive]
          this.[l.name] = super.[l.name]();
            [else]
          this.[l.name] = com.google.common.base.Preconditions.checkNotNull(super.[l.name]());
            [/if]
          lazyBitmap |= [maskConstantName];
        }
      }
    }
    return [l.name];
  }
[/for]
[/template]

[template generateBuilder Type type]

[for setters = type.settableAttributes, getters = type.implementedAttributes]
/**
 * Builds instances of {@link [type.name]}.
 * Builder is not thread safe and generally should not be stored in fields and collections,
 * but used immediately to create instances.
 */
@javax.annotation.concurrent.NotThreadSafe
[if type.hasAbstractBuilder]
[type.accessPrefix]static final class Builder
    extends [type.name].Builder {
[else]
[type.accessPrefix]static final class Builder {
[/if]
  private static final String REQUIRED_ATTRIBUTE =
      "Cannot build [type.name]: required attribute '%s' is not set";

  [for v in setters]
[if v.collectionType]
  private com.google.common.collect.Immutable[v.rawCollectionType].Builder<[v.elementType]> [v.name]Builder =
      com.google.common.collect.Immutable[v.rawCollectionType].builder();
[else if v.optionalType]
  private [v.type] [v.name] = com.google.common.base.Optional.absent();
[else if v.mapType]
  private com.google.common.collect.ImmutableMap.Builder<[v.wrappedElementType], [v.wrappedSecondaryElementType]> [v.name]Builder =
      com.google.common.collect.ImmutableMap.builder();
[else if v.primitive]
  private [v.type] [v.name];
  private boolean [v.name]IsSet;
[else]
  @javax.annotation.Nullable
  private [v.type] [v.name];
[/if]
  [/for]
  [if type.generateOrdinalValue]
  private Domain domain = Domain.get();

  public Builder domain(Domain domain) {
    this.domain = com.google.common.base.Preconditions.checkNotNull(domain);
    return this;
  }
  [/if]

  private Builder() {
  }

  @Override
  public String toString() {
    return com.google.common.base.MoreObjects.toStringHelper("[type.simpleName].Builder")
        .omitNullValues()
  [for v in setters]
    [if v.collectionType or v.mapType]
        .add("[v.name]", [v.name]Builder.build())
    [else if v.optionalType]
        .add("[v.name]", [v.name].orNull())
    [else]
        .add("[v.name]", [v.name])
    [/if]
  [/for]
        .toString();
  }

  /**
   * Adjust builder with values from provided {@link [type.name]} instance.
   * Absent optional values will not be copied (will not override current).
   * Collection elements will be added, not replaced.
   * @param fromInstance instance to copy values from
   * @return {@code this} builder for chained invocation
   */
  public Builder copy([type.name] fromInstance) {
    com.google.common.base.Preconditions.checkNotNull(fromInstance);
  [for v in setters]
    [if v.collectionType]
    addAll[toUpper v.name](fromInstance.[v.name]());
    [else if v.optionalType]
    [v.type] optional[toUpper v.name] = fromInstance.[v.name]();
    if (optional[toUpper v.name].isPresent()) {
      [v.name] = optional[toUpper v.name];
    }
    [else if v.mapType]
    putAll[toUpper v.name](fromInstance.[v.name]());
    [else]
    [v.name](fromInstance.[v.name]());
    [/if]
  [/for]
    return this;
  }
  [for v in setters]
  [if v.collectionType]

  /**
   * Adds one element to {@link [type.name]#[v.name]()} [toLower v.rawCollectionType].
   * @param [v.name]Element single [v.name] element
   * @return {@code this} builder for chained invocation
   */
  public Builder add[toUpper v.name]([v.unwrappedElementType] [v.name]Element) {
    [v.name]Builder.add([v.name]Element);
    return this;
  }

  /**
   * Adds elements to {@link [type.name]#[v.name]()} [toLower v.rawCollectionType].
   * @param [v.name]Elements iterable of [v.name] elements
   * @return {@code this} builder for chained invocation
   */
  public Builder addAll[toUpper v.name](Iterable<[v.consumedElementType]> [v.name]Elements) {
    [v.name]Builder.addAll([v.name]Elements);
    return this;
  }
  [else if v.optionalType]

  /**
   * Initializes present value for optional {@link [type.name]#[v.name]()}.
   * @param [v.name] value for [v.name], non-null
   * @return {@code this} builder for chained invocation
   */
  public Builder [v.name]([v.unwrappedElementType] [v.name]) {
    this.[v.name](com.google.common.base.Optional.of([v.name]));
    return this;
  }

  /**
   * Initializes optional value for {@link [type.name]#[v.name]()}.
   * @param [v.name] value for [v.name], non-null
   * @return {@code this} builder for chained invocation
   */
  public Builder [v.name](com.google.common.base.Optional<[v.wrappedElementType]> [v.name]) {
    this.[v.name] = com.google.common.base.Preconditions.checkNotNull([v.name]);
    return this;
  }
  [else if v.mapType]
    [for gE = v.consumedElementType, uK = v.unwrappedElementType, wK = v.wrappedElementType, uV = v.unwrappedSecondaryElementType, wV = v.wrappedSecondaryElementType]

  /**
   * Put one entry to {@link [type.name]#[v.name]()} map.
   * @param key the key in [v.name] map
   * @param value the associated value in [v.name] map
   * @return {@code this} builder for chained invocation
   */
  public Builder put[toUpper v.name]([uK] key, [uV] value) {
    [v.name]Builder.put(key, value);
    return this;
  }

  /**
   * Put one entry to {@link [type.name]#[v.name]()} map. Nulls are not permitted
   * @param entry the key and value entry
   * @return {@code this} builder for chained invocation
   */
  public Builder put[toUpper v.name](java.util.Map.Entry<[gE], ? extends [wV]> entry) {
    [v.name]Builder.put(entry);
    return this;
  }

  /**
   * Put all mappings from specified map as entries to {@link [type.name]#[v.name]()} map. Nulls are not permitted
   * @param [v.name]Entries to be added to [v.name] map
   * @return {@code this} builder for chained invocation
   */
  public Builder putAll[toUpper v.name](java.util.Map<[gE], ? extends [wV]> [v.name]Entries) {
    [v.name]Builder.putAll([v.name]Entries);
    return this;
  }

    [/for]
  [else]

  /**
   * Initializes value for {@link [type.name]#[v.name]()}.
  [if v.generateDefault]
   * <p><em>If not set, this attribute will have {@link [type.name]#[v.name]() default value}.</em>
  [/if]
   * @param [v.name] value for [v.name], non-null
   * @return {@code this} builder for chained invocation
   */
  public Builder [v.name]([v.type] [v.name]) {
    [if v.primitive]
    this.[v.name] = [v.name];
    [v.name]IsSet = true;
    [else]
    this.[v.name] = com.google.common.base.Preconditions.checkNotNull([v.name]);
    [/if]
    return this;
  }
  [/if]
  [/for]

  /**
   * Builds new {@link [type.name]}.
   * @return immutable instance of [type.name]
   */
  public [type.defName] build() {
  [for v in setters if not v.generateDefault]
  [if v.primitive]
    com.google.common.base.Preconditions.checkState([v.name]IsSet, REQUIRED_ATTRIBUTE, "[v.name]");
  [else if not v.containerType]
    com.google.common.base.Preconditions.checkState([v.name] != null, REQUIRED_ATTRIBUTE, "[v.name]");
  [/if]
  [/for]
    return checkPreconditions(new [type.defName](this));
  }
}
[/for]
[/template]

[template generateConstructorDefaultAttributes Type type Attribute... attributes]
[for v in attributes if not (v.generateDefault or v.generateDerived), n = v.name]
  [if v.optionalType]
this.[n] = com.google.common.base.Optional.absent();
  [else if v.mapType]
this.[n] = com.google.common.collect.ImmutableMap.of();
  [else if v.collectionType]
this.[n] = com.google.common.collect.Immutable[v.rawCollectionType].of();
  [else]
    [output.error]
      Could not generate constructor. Attribute '[v.name]' does not have default value.
    [/output.error]
  [/if]
[/for]
[for v in attributes if v.generateDefault or v.generateDerived, n = v.name]
  [if v.primitive]
this.[n] = super.[n]();
  [else]
this.[n] = com.google.common.base.Preconditions.checkNotNull(super.[n]());
  [/if]
[/for]
[/template]

[template generateImmutable Type type]
[for setters = type.settableAttributes, getters = type.implementedAttributes]

[for v in getters]
  private final [v.implementationType] [v.name];
[/for]
[if type.usePrehashed]
  private final int hashCode;
[/if]
[if type.generateOrdinalValue]
  private final int ordinal;
  private final Domain domain;
[/if]
[if type.useSingleton]

  private [type.defName]() {
    [generateConstructorDefaultAttributes type type.implementedAttributes]
    [generateAfterConstruction type false]
  }
[/if]
[if type.useConstructor]

  private [type.defName]([for v in type.constructorArguments][if not for.first],[/if]
      [v.type] [v.name][/for]) {
[for v in type.constructorArguments, n = v.name]
  [if v.collectionType or v.mapType]
    this.[n] = [immutableCollectionCopyOf v n];
  [else if v.primitive]
    this.[n] = [n];
  [else]
    this.[n] = com.google.common.base.Preconditions.checkNotNull([n]);
  [/if]
[/for]
    [generateConstructorDefaultAttributes type type.constructorOmited]
    [generateAfterConstruction type false]
  }
[/if]
[if type.useBuilder]

  private [type.defName](Builder builder) {
[for v in getters if not v.generateDerived, n = v.name]
  [if v.generateOrdinalValueSet or (v.generateEnumSet or v.generateEnumMap)]
    this.[n] = [immutableCollectionCopyOf v]builder.[n]Builder.build()[/immutableCollectionCopyOf];
  [else if v.collectionType or v.mapType]
    this.[n] = builder.[n]Builder.build();
  [else if not v.generateDefault]
    this.[n] = builder.[n];
  [/if]
[/for]
[-- Generate default values comes after required values]
[for v in getters, n = v.name]
[if v.primitive and v.generateDefault]
    this.[n] = builder.[n]IsSet
        ? builder.[n]
        : super.[n]();
[else if v.generateDefault]
    this.[n] = builder.[n] != null
        ? builder.[n]
        : super.[n]();
[else if v.primitive and v.generateDerived]
    this.[n] = super.[n]();
[else if v.generateDerived]
    this.[n] = com.google.common.base.Preconditions.checkNotNull(super.[n]());
[/if]
[/for]
    [generateAfterConstruction type true]
  }
[/if]
[if type.useCopyMethods]

  private [type.defName](
      [type.defName] copiedInstance[for v in getters],
      [v.implementationType] [v.name][/for]) {
  [for v in getters]
    this.[v.name] = [v.name];
  [/for]
    [generateAfterConstruction type false]
  }
  [generateCopyMethods type]
[/if]
  [generateAccessorMethods type]
  [generateObjectUtilityMethods type]
[/for]
[/template]

[template generateAccessorMethods Type type]
  [for v in type.implementedAttributes]

@Override
public [v.implementationType] [v.name]() {
  return [v.name];
}
  [/for]
[generateGetters type]
  [if type.generateOrdinalValue]

@Override
public int ordinal() {
  return ordinal;
}
  [/if]
[/template]

[template generateObjectUtilityMethods Type type]
[for getters = type.equivalenceAttributes]
[if not type.equalToDefined]

@Override
public boolean equals(Object another) {
  [if type.useInterned or type.generateOrdinalValue]
  return this == another;
  [else]
  return this == another
      || (another instanceof [type.defName] && equalTo(([type.defName]) another));
  [/if]
}
[/if]

private boolean equalTo([type.defName] another) {
  return true[for v in getters]
      && [equalsAttribute v][/for];
}

private int computeHashCode() {
  int h = 31;
  [if getters.isEmpty]
  h = h * 17 + "[type.name]".hashCode();
  [else]
[for v in getters]
[if not v.primitive]
  h = h * 17 + [v.name].hashCode();
[else if v.type eq 'int']
  h = h * 17 + [v.name];
[else]
  h = h * 17 + com.google.common.primitives.[toUpper v.type]s.hashCode([v.name]);
[/if]
[/for]
  [/if]
  return h;
}
[if not type.hashCodeDefined]

@Override
public int hashCode() {
  [if type.usePrehashed]
  return hashCode;
  [else]
  return computeHashCode();
  [/if]
}
[/if]
[/for]
[generateToString type]
[/template]

[template generateToString Type type]
[if not type.toStringDefined]

@Override
public String toString() {
  return com.google.common.base.MoreObjects.toStringHelper("[type.simpleName]")
  [for v in type.equivalenceAttributes]
      .add("[v.name]", [v.name]())
  [/for]
      .toString();
}
[/if]
[/template]

[template generateAfterConstruction Type type Boolean usingBuilder]
  [if type.usePrehashed]
this.hashCode = this.computeHashCode();
  [/if]
  [if type.generateOrdinalValue][-- Assigning dummy ordinal value to be changed on interning --]
this.ordinal = 0;
    [if usingBuilder]
this.domain = builder.domain;
    [else]
[-- Default static ordinal domain --]
this.domain = Domain.get();
    [/if]
  [/if]
[/template]

[template generateReturnCopyContextual Type type Attribute modified]
return checkPreconditions(new [type.defName](
    this[for a in type.implementedAttributes],
    [if a.name eq modified.name]newValue[else]this.[a.name][/if][/for]));
[/template]

[template generateCopyMethods Type type]
  [for v in type.settableAttributes]
    [if v.collectionType]

/**
 * Copy current immutable object with elements that replace content of {@link [type.name]#[v.name]()}.
 * Shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
 * @param elements iterable of [v.name] elements to add
 * @return modified copy of the {@code this} object
 */
public [type.defName] with[toUpper v.name](Iterable<[v.consumedElementType]> elements) {
  if (this.[v.name] == elements) {
    return this;
  }
  [v.implementationType] newValue = [immutableCollectionCopyOf v 'elements'];
  [generateReturnCopyContextual type v]
}
    [else if v.optionalType]

/**
 * Copy current immutable object by setting present value for optional {@link [type.name]#[v.name]()}.
 * @param value value for [v.name], non-null
 * @return modified copy of the {@code this} object
 */
public [type.defName] with[toUpper v.name]([v.unwrappedElementType] value) {
  [v.implementationType] newValue = com.google.common.base.Optional.of(value);
  [generateReturnCopyContextual type v]
}

/**
 * Copy current immutable object by setting optional value for {@link [type.name]#[v.name]()}.
 * Shallow reference equality check on optional value is used to prevent copying of the same value by returning {@code this}.
 * @param optional value for [v.name], non-null
 * @return modified copy of the {@code this} object
 */
public [type.defName] with[toUpper v.name](com.google.common.base.Optional<[v.wrappedElementType]> optional) {
  if (this.[v.name] == optional) {
    return this;
  }
  [v.implementationType] newValue = com.google.common.base.Preconditions.checkNotNull(optional);
  [generateReturnCopyContextual type v]
}
    [else if v.mapType]
    [for gE = v.consumedElementType, uK = v.unwrappedElementType, wK = v.wrappedElementType, uV = v.unwrappedSecondaryElementType, wV = v.wrappedSecondaryElementType]

/**
 * Copy current immutable object by replacing {@link [type.name]#[v.name]()} map with specified map.
 * Nulls are not permitted as keys or values.
 * Shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
 * @param map to be added to [v.name] map
 * @return modified copy of the {@code this} object
 */
public [type.defName] with[toUpper v.name](java.util.Map<[gE], ? extends [wV]> map) {
  if (this.[v.name] == map) {
    return this;
  }
  [v.implementationType] newValue = [immutableCollectionCopyOf v 'map'];
  [generateReturnCopyContextual type v]
}
    [/for]
    [else]

/**
 * Copy current immutable object by setting value for {@link [type.name]#[v.name]()}.
 [if v.primitive and (not v.floatType)]
 * Value equality check is used to prevent copying of the same value by returning {@code this}.
 [else if not v.primitive]
 * Shallow reference equality check is used to prevent copying of the same value by returning {@code this}.
 [/if]
 * @param value value for [v.name], non-null
 * @return modified copy of the {@code this} object
 */
public [type.defName] with[toUpper v.name]([v.type] value) {
    [if not v.floatType]
  if (this.[v.name] == value) {
    return this;
  }
    [/if]
    [if v.primitive]
  [v.implementationType] newValue = value;
    [else]
  [v.implementationType] newValue = com.google.common.base.Preconditions.checkNotNull(value);
    [/if]
  [generateReturnCopyContextual type v]
}
    [/if]
  [/for]
[/template]

[template generateGetters Type type]
  [if type.generateGetters]
    [for v in type.allAccessibleAttributes]

/**
 * Gets the value of {@link [type.name]#[v.name]()} attribute.
[if v.optionalType]
 * @return value of [v.name] if present, {@code null} if absent
[else]
 * @return value for [v.name], non-null
[/if]
 */
  [for line in v.annotations]
[line]
  [/for]
  [if v.optionalType]
@javax.annotation.Nullable
public [v.wrappedElementType] get[toUpper v.name]() {
  return [v.name]().orNull();
}
  [else]
public [v.implementationType] [if v.boolean]is[else]get[/if][toUpper v.name]() {
  return [v.name]();
}
  [/if]
    [/for]
  [/if]
[/template]

[template immutableCollectionCopyOf Attribute a String expression][output.trim]
[if a.generateEnumSet]
  com.google.common.collect.Sets.immutableEnumSet([expression])
[else if a.generateOrdinalValueSet]
  org.immutables.common.collect.ImmutableOrdinalSet.copyOf([expression])
[else if a.collectionType]
  com.google.common.collect.Immutable[a.rawCollectionType].copyOf([expression])
[else if a.generateEnumMap]
  com.google.common.collect.Maps.immutableEnumMap([expression])
[else if a.mapType]
  com.google.common.collect.ImmutableMap.copyOf([expression])
[else]
  [expression]
[/if]
[/output.trim][/template]

[template equalsAttribute Attribute a][output.trim]
[if a.float]
  Float.floatToIntBits([a.name]) == Float.floatToIntBits(another.[a.name])
[else if a.double]
  Double.doubleToLongBits([a.name]) == Double.doubleToLongBits([a.name])    
[else if a.primitive]
  [a.name] == another.[a.name]
[else]
  [a.name].equals(another.[a.name])
[/if]
[/output.trim][/template]
