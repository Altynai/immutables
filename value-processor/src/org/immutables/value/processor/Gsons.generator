[template generate]
  [for type in values.values if type.generateTypeAdapted and type.topLevel]

[output.java type.package (type.name 'TypeAdapters')]
[generateTypeAdapters type type.allValues]
[/output.java]

[output.service 'com.google.gson.TypeAdapterFactory']
[if type.package][type.package].[/if][type.name]TypeAdapters
[/output.service]

  [/for]
[/template]

[template checkAttributes Type type]
[for a in type.implementedAttributes if a.gsonIgnore and a.mandatory]
[-- mandatory constructor arguments are not checked, should they? --]
[output.error]
@Gson.Ignore could not be used on mandatory attribute '[type.typeAbstract.relative].[a.name]'
[/output.error]
[/for]
[/template]

[template generateTypeAdapters Type type Type... allValues]
[if type.package]
package [type.package];
[/if]

[-- replace with fully qualified names where needed --]
import com.google.gson.*;
import com.google.gson.stream.*;
import com.google.gson.reflect.*;

import javax.annotation.*;
import java.io.IOException;
// Generated imports

/**
 * Streamer that could marshal and unmarshal instances of {@code [type.typeAbstract.relative]}.
 * Uses Gson JSON processor API.
 */
@SuppressWarnings("all")
@Generated({"Gsons.generator", "[type.typeAbstract.relative]"})
@ParametersAreNonnullByDefault
public final class [type.name]TypeAdapters
    implements TypeAdapterFactory {

  @SuppressWarnings("unchecked") // safe unchecked, type is verified by type token equality
  @Override
  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
    [for v in allValues]
    if ([v.name]TypeAdapter.adapts(type)) {
      return (TypeAdapter<T>) new [v.name]TypeAdapter(gson);
    }
    [/for]
    return null;
  }

  @Override
  public String toString() {
    return "[type.name]TypeAdapted{}";
  }
  [for v in allValues]
  [generateTypeAdapter v]
  [/for]
}
[/template]

[template generateTypeAdapter Type type]
[for allAttributes = type.allMarshalingAttributes, t = type.typeAbstract.relative, im = type.typeImmutable.relative]

private static class [type.name]TypeAdapter extends TypeAdapter<[t]> {
  private static final TypeToken<[t]> [toConstant type.name]_ABSTRACT = TypeToken.get([t].class);
  private static final TypeToken<[im]> [toConstant type.name]_IMMUTABLE =  TypeToken.get([im].class);
  [for a in allAttributes]
    [if a.requiresMarshalingAdapter]
  private static final TypeToken<[a.elementType]> [toConstant a.name]_TYPE_TOKEN = [if a.nonRawElemementType]new TypeToken<[a.elementType]>() {}[else]TypeToken.get([a.elementType].class)[/if];
    [/if]
    [if a.requiresMarshalingSecondaryAdapter]
  private static final TypeToken<[a.secondaryElementType]> [toConstant a.name]_SECONDARY_TYPE_TOKEN = new TypeToken<[a.secondaryElementType]>() {};
    [/if]
  [/for]
  [for a in allAttributes]
    [if a.requiresMarshalingAdapter]
  private final TypeAdapter<[a.elementType]> [a.name]Adapter;
    [/if]
    [if a.requiresMarshalingSecondaryAdapter]
  private final TypeAdapter<[a.secondaryElementType]> [a.name]SecondaryAdapter;
    [/if]
  [/for]

  [type.name]TypeAdapter(Gson gson) {
  [for a in allAttributes]
    [if a.requiresMarshalingAdapter]
    this.[a.name]Adapter = gson.getAdapter([toConstant a.name]_TYPE_TOKEN);
    [/if]
    [if a.requiresMarshalingSecondaryAdapter]
    this.[a.name]SecondaryAdapter = gson.getAdapter([toConstant a.name]_SECONDARY_TYPE_TOKEN);
    [/if]
  [/for]
  }

  static boolean adapts(TypeToken<?> type) {
    return [toConstant type.name]_ABSTRACT.equals(type)
        || [toConstant type.name]_IMMUTABLE.equals(type);
  }

  @Override
  public void write(JsonWriter out, [t] value) throws IOException {
    marshal[type.name](out, value);
  }

  @Override
  public [t] read(JsonReader in) throws IOException {
    return unmarshal[type.name](in);
  }
  [generateMarshalingMethods type]
  [generateUnmarshalingMethods type]
}
[/for]
[/template]

[template generateMarshalingMethods Type type]

void marshal[type.name](JsonWriter out, [type.typeAbstract.relative] instance)
    throws IOException {
[if type.useConstructorOnly]
  [for ca = type.constructorArguments]
  [if singular ca]
  [for a in ca]
  [generateMarshalConstructorValue type a]
  [/for]
  [else]
  out.beginArray();
  [for a in ca]
  [generateMarshalConstructorValue type a]
  [/for]
  out.endArray();
  [/if]
  [/for]
[else]
  out.beginObject();
  [for a in type.marshaledAttributes]
  [generateMarshalAttributeValue type a]
  [/for]
  out.endObject();
[/if]
}
[/template]

[template generateMarshalConstructorValue Type type Attribute a]
  [if a.nullable]
[a.atNullability][a.type] [a.name]Value = instance.[a.names.get]();
if ([a.name]Value != null) {
  [generatePossiblyPolymorphicTypeMarshalAttributeValue type a (a.name 'Value') false]
} else {
  out.writeNull();
}
  [else if a.optionalType]
[a.type] [a.name]Value = instance.[a.names.get]();
if ([a.name]Value.isPresent()) {
  [a.unwrappedElementType] unwrapped[a.name]Value = [a.name]Value.get();
  [generatePossiblyPolymorphicTypeMarshalAttributeValue type a ('unwrapped' a.name 'Value') false]
} else {
  out.writeNull();
}
  [else if a.mapType]
[a.type] [a.name]Map = instance.[a.names.get]();
out.beginObject();
for (java.util.Map.Entry<[a.wrappedElementType], [a.wrappedSecondaryElementType]> e : [a.name]Map.entrySet()) {
  [-- only use toString with objects and boxed primitives]
  out.name(e.getKey().toString());
  [-- here we assign to a unwrapped variable so overload resolution will precise]
  [a.unwrappedSecondaryElementType] value = e.getValue();
  [generatePossiblyPolymorphicTypeMarshalAttributeValue type a 'value' true]
}
out.endObject();
  [else if a.collectionType]
out.beginArray();
for ([a.unwrappedElementType] e : instance.[a.names.get]()) {
  [generatePossiblyPolymorphicTypeMarshalAttributeValue type a 'e' false]
}
out.endArray();
  [else]
[generatePossiblyPolymorphicTypeMarshalAttributeValue type a ('instance.' a.names.get '()') false]
  [/if]
[/template]

[template generateMarshalAttributeValue Type type Attribute a]
  [if a.nullable]
[a.atNullability][a.type] [a.name]Value = instance.[a.names.get]();
if ([a.name]Value != null) {
  out.name("[a.marshaledName]");
  [generatePossiblyPolymorphicTypeMarshalAttributeValue type a (a.name 'Value') false]
    [if a.forceEmpty]
} else {
  out.name("[a.marshaledName]");
  out.nullValue();
    [/if]
}
  [else if a.optionalType]
[a.type] [a.name]Value = instance.[a.names.get]();
if ([a.name]Value.isPresent()) {
  out.name("[a.marshaledName]");
  [a.unwrappedElementType] unwrapped[a.name]Value = [a.name]Value.get();
  [generatePossiblyPolymorphicTypeMarshalAttributeValue type a ('unwrapped' a.name 'Value') false]
    [if a.forceEmpty]
} else {
  out.name("[a.marshaledName]");
  out.nullValue();
    [/if]
}
  [else if a.mapType]
[a.type] [a.name]Map = instance.[a.names.get]();
if (![a.name]Map.isEmpty()) {
  out.name("[a.marshaledName]");
  out.beginObject();
  for (java.util.Map.Entry<[a.wrappedElementType],[a.wrappedSecondaryElementType]> e : [a.name]Map.entrySet()) {
    [-- only use toString with objects and boxed primitives]
    out.name(e.getKey().toString());
    [-- here we assign to a unwrapped variable so overload resolution will precisely]
    [a.unwrappedSecondaryElementType] value = e.getValue();
    [generatePossiblyPolymorphicTypeMarshalAttributeValue type a 'value' true]
  }
  out.endObject();
    [if a.forceEmpty]
} else {
  out.name("[a.marshaledName]");
  out.beginObject();
  out.endObject();
    [/if]
}
  [else if a.collectionType]
[a.type] [a.name]Elements = instance.[a.names.get]();
if (![a.name]Elements.isEmpty()) {
  out.name("[a.marshaledName]");
  out.beginArray();
  for ([a.unwrappedElementType] e : [a.name]Elements) {
    [generatePossiblyPolymorphicTypeMarshalAttributeValue type a 'e' false]
  }
  out.endArray();
    [if a.forceEmpty]
} else {
  out.name("[a.marshaledName]");
  out.beginArray();
  out.endArray();
    [/if]
}
  [else]
out.name("[a.marshaledName]");
[generatePossiblyPolymorphicTypeMarshalAttributeValue type a ('instance.' a.name '()') false]
  [/if]
[/template]

[template generateUnmarshalingMethods Type type]

private char requireChar(String string) {
  if (string.length() == 1) {
    return string.charAt(0);
  }
  throw new IllegalArgumentException(
      String.format("Expected string with a single character but was: '%s'", string));
}
[if type.useSingletonOnly]

[type.typeAbstract.relative] unmarshal[type.name](JsonReader in)
    throws IOException {
  in.skipValue();
  return [type.factoryInstance]();
}
[else if type.useConstructorOnly]

[for ca = type.constructorArguments]
[type.typeAbstract.relative] unmarshal[type.name](JsonReader in)
    throws IOException {
[if singular ca]
  [for a in ca]
  boolean inArray = in.peek() == JsonToken.BEGIN_ARRAY;
  if (inArray) {
    in.beginArray();
  }
  [type.typeAbstract.relative] instance = [type.factoryOf.relative](unmarshalConstructorArgument[toUpper a.name](in));
  if (inArray) {
    in.endArray();
  }
  return instance;
  [/for]
[else]
  in.beginArray();
  [type.typeAbstract.relative] instance = [type.factoryOf.relative]([for a in ca][if not for.first],[/if]
    unmarshalConstructorArgument[toUpper a.name](in)[/for]);
  in.endArray();
  return instance;
[/if]
}
[for a in ca]
[generateConstructorArgumentUnmarshal type a]
[/for]
[/for]
[else]    

[type.typeAbstract.relative] unmarshal[type.name](JsonReader in)
    throws IOException {
  [type.typeBuilder.relative] builder = [type.factoryBuilder.relative]();
    [if type.unmarshaledAttributes]
  in.beginObject();
  while (in.hasNext()) {
    unmarshalAttribute(in, builder, in.nextName());
  }
  in.endObject();
    [else]
  in.skipValue();
    [/if]
  return builder.[type.names.build]();
}

private void unmarshalAttribute(JsonReader in, [type.typeBuilder.relative] builder, String attributeName)
    throws IOException {
  switch (attributeName.charAt(0)) {
  [for Mm mm = byFirstCharacter type.unmarshaledAttributes,
     e in mm.asMap.entrySet]
  case '[e.key]':
    [for a in e.value]
    if ("[a.marshaledName]".equals(attributeName)) {
      unmarshalAttribute[toUpper a.name](in, builder);
      return;
    }
    [/for]
    break;
  [/for]
  default:
  }
  unmarshalUnknownAttribute(in, attributeName);
}

private void unmarshalUnknownAttribute(JsonReader in, String attributeName)
    throws IOException {
  in.skipValue();
}
[for s in type.unmarshaledAttributes]  
[generateUnmarshalAttribute type s]
[/for]
[/if]
[/template]

[template generateConstructorArgumentUnmarshal Type type Attribute a]

private [a.atNullability][constructorAcceptType a] unmarshalConstructorArgument[toUpper a.name](JsonReader in)
    throws IOException {
  [if a.primitive]
  return [simpleTypeNext a.type];
  [else]
  [generateConstructorArgumentComplexUnmarshal type a]
  [/if]
}
  [if a.mapType]
[generateMapUnmarshalMethod type a]
  [/if]
[/template]

[template generateConstructorArgumentComplexUnmarshal Type type Attribute a]
  [if a.nullable]
JsonToken t = in.peek();
if (t == JsonToken.NULL) {
  in.nextNull();
  return null;
}
[generatePossiblyPolymorphicTypeUnmarshalAttributeValue type a a.type a.unwrapperOrRawElementType false]
return value;
  [else if a.optionalType]
JsonToken t = in.peek();
if (t == JsonToken.NULL) {
  in.nextNull();
  return [if a.jdkOptional]java.util.Optional.empty()[else][guava].base.Optional.absent()[/if];
}
    [if a.unwrappedElementPrimitiveType or (a.unwrappedElementType eq 'java.lang.String')]
return [a.rawType].<[a.elementType]>of([simpleTypeNext a.unwrappedElementType]);
    [else]
[generatePossiblyPolymorphicTypeUnmarshalAttributeValue type a a.wrappedElementType a.unwrapperOrRawElementType false]
return [a.rawType].of(value);
    [/if]
  [else if a.mapType]
return constructMapping[toUpper a.name](unmarshalEntries[toUpper a.name](in));
  [else if a.collectionType]
java.util.List<[a.elementType]> elements = new java.util.ArrayList<[a.elementType]>();
[generateCollectionUnmarshalCode type a 'elements.add']
return elements;
  [else]
[generatePossiblyPolymorphicTypeUnmarshalAttributeValue type a a.type a.rawType false]
return value;
  [/if]
[/template]

[template generateUnmarshalAttribute Type type Attribute a]

private void unmarshalAttribute[toUpper a.name](JsonReader in, [type.typeBuilder.relative] builder)
    throws IOException {
  [if a.primitive]
  builder.[a.names.init]([simpleTypeNext a.type]);
  [else]
  [generateComplexTypeUnmarshalAttribute type a]
  [/if]
}
[if a.mapType]
[generateMapUnmarshalMethod type a]
[/if]
[/template]

[template generateMapUnmarshalMethod Type type Attribute a]
[let mapParams]<[a.wrappedElementType], [a.wrappedSecondaryElementType]>[/let]
[let entryType]java.util.Map.Entry[mapParams][/let]
[if type.useConstructor]

private [constructorAcceptType a] constructMapping[toUpper a.name](java.util.List<[entryType]> entries) {
[if a.typeKind.isListMultimap]
  [guava].collect.ListMultimap[mapParams] mapping = [guava].collect.ArrayListMultimap.create(entries.size(), 2);
[else if a.typeKind.isSetMultimap]
  [guava].collect.SetMultimap[mapParams] mapping = [guava].collect.LinkedHashMultimap.create(entries.size(), 2);
[else if a.typeKind.isMultimap]
  [guava].collect.Multimap[mapParams] mapping = [guava].collect.LinkedHashMultimap.create(entries.size(), 2);
[else]
  java.util.Map[mapParams] mapping = new java.util.LinkedHashMap[mapParams](entries.size());
[/if]
  for ([entryType] entry : entries) {
    mapping.put(entry.getKey(), entry.getValue());
  }
  return mapping;
}
[/if]

private java.util.List<[entryType]> unmarshalEntries[toUpper a.name](JsonReader in)
    throws IOException {
  if (in.peek() == JsonToken.NULL) {
    in.nextNull();
    return java.util.Collections.emptyList();
  }
  java.util.List<[entryType]> entries = new java.util.ArrayList<[entryType]>();
  in.beginObject();
  while(in.hasNext()) {
    String rawKey = in.nextName();
[if a.unwrappedElementPrimitiveType]
  [if a.unwrappedElementType eq 'char']
    char key = requireChar(rawKey);
  [else]
    [a.unwrappedElementType] key = [a.wrappedElementType].parse[toUpper a.unwrappedElementType](rawKey);
  [/if]
[else if a.wrappedElementType eq 'java.lang.String']
    [a.wrappedElementType] key = rawKey;
[else]
    [a.wrappedElementType] key = unmarshal(in, ([a.wrappedElementType]) null, [a.unwrapperOrRawElementType].class);
[/if]
[if a.unwrappedSecondaryElementPrimitiveType or (a.wrappedSecondaryElementType eq 'java.lang.String')]
    [a.unwrappedSecondaryElementType] value = [simpleTypeNext a.unwrappedSecondaryElementType];
[else]
    [generatePossiblyPolymorphicTypeUnmarshalAttributeValue type a a.wrappedSecondaryElementType a.unwrapperOrRawSecondaryElementType true]
[/if]
    entries.add(new java.util.AbstractMap.SimpleEntry[mapParams](key, value));
  }
  in.endObject();

  return entries;
}
[/template]

[template collectionUnmarshalCaseNullSingleArray Invokable unmarshalCollectionElement]
JsonToken t = in.peek();
if (t == JsonToken.BEGIN_ARRAY) {
  in.beginArray();
  while(in.hasNext()) {
    [unmarshalCollectionElement]
  }
  in.endArray();
} else if (t == JsonToken.NULL) {
  in.nextNull();
} else {
  [unmarshalCollectionElement]
}
[/template]

[template generateCollectionUnmarshalCode Type type Attribute a String collectorExpression]
[collectionUnmarshalCaseNullSingleArray]
  [if a.unwrappedElementPrimitiveType or (a.unwrappedElementType eq 'java.lang.String')]
[collectorExpression]([simpleTypeNext a.unwrappedElementType]);
  [else]
[generatePossiblyPolymorphicTypeUnmarshalAttributeValue type a a.wrappedElementType a.unwrapperOrRawElementType false]
[collectorExpression](value);
  [/if]
[/collectionUnmarshalCaseNullSingleArray]
[/template]

[template generateComplexTypeUnmarshalAttribute Type type Attribute a]
  [if a.nullable]
JsonToken t = in.peek();
if (t == JsonToken.NULL) {
  in.nextNull();
} else {
    [if a.stringType]
  builder.[a.names.init]([simpleTypeNext a.unwrappedElementType]);
    [else]
  [generatePossiblyPolymorphicTypeUnmarshalAttributeValue type a a.type a.unwrapperOrRawElementType false]
  builder.[a.names.init](value);
    [/if]
}
  [else if a.stringType]
  builder.[a.names.init]([simpleTypeNext a.unwrappedElementType]);
  [else if a.optionalType]
JsonToken t = in.peek();
if (t == JsonToken.NULL) {
  in.nextNull();
} else {
    [if a.unwrappedElementPrimitiveType or (a.unwrappedElementType eq 'java.lang.String')]
  builder.[a.names.init]([simpleTypeNext a.unwrappedElementType]);
    [else]
  [generatePossiblyPolymorphicTypeUnmarshalAttributeValue type a a.wrappedElementType a.unwrapperOrRawElementType false]
  builder.[a.names.init](value);
    [/if]
}
  [else if a.mapType]
for (java.util.Map.Entry<[a.wrappedElementType], [a.wrappedSecondaryElementType]> entry : unmarshalEntries[toUpper a.name](in)) {
  builder.[a.names.put](entry);
}
  [else if a.collectionType]
[generateCollectionUnmarshalCode type a ('builder.' a.names.add)]
  [else]
[generatePossiblyPolymorphicTypeUnmarshalAttributeValue type a a.type a.rawType false]
builder.[a.names.init](value);
  [/if]
[/template]

[template generatePossiblyPolymorphicTypeUnmarshalAttributeValue Type type Attribute attribute String genericType String rawType Boolean secondary]
[genericType] value =
[for cx = attribute.expectedSubclasses]
  [if cx]
    ([genericType]) unmarshalWithOneOfStreamers(in, "[type.typeAbstract.relative]", "[attribute.name]", "[genericType]"[for c in cx],
        [c.packaged][c.name]Streamer.instance()[/for]);
  [else]
    [if secondary]
      [if attribute.requiresMarshalingSecondaryAdapter]
    [attribute.name]SecondaryAdapter.read(in);
      [else]
    [simpleTypeNext attribute.secondaryElementType];
      [/if]
    [else]
      [if attribute.requiresMarshalingAdapter]
    [attribute.name]Adapter.read(in);
      [else]
    [simpleTypeNext attribute.elementType];
      [/if]
    [/if]
  [/if]
[/for]
[/template]

[template generatePossiblyPolymorphicTypeMarshalAttributeValue Type type Attribute attribute String variableName Boolean secondary]
[for cx = attribute.expectedSubclasses]
  [if cx]
marshalWithOneOfStreamers(out, [variableName][for c in cx],
    [c.packaged][c.name]Streamer.instance()[/for]);
  [else]
    [if secondary]
      [if attribute.requiresMarshalingSecondaryAdapter]
[attribute.name]SecondaryAdapter.write(out, [variableName]);
      [else]
[simpleTypeWrite attribute.secondaryElementType variableName]
      [/if]
    [else]
      [if attribute.requiresMarshalingAdapter]
[attribute.name]Adapter.write(out, [variableName]);
      [else]
[simpleTypeWrite attribute.elementType variableName]
      [/if]
    [/if]
  [/if]
[/for]
[/template]

[template simpleTypeWrite String typeName String variableName]
[if typeName eq 'char']
out.value(String.valueOf([variableName]));
[else]
out.value([variableName]);
[/if]
[/template]

[template simpleTypeNext String typeName][output.trim]
[if typeName eq 'boolean']
  in.nextBoolean()
[else if typeName eq 'byte']
  (byte) in.nextInt()
[else if typeName eq 'short']
  (short) in.nextInt()
[else if typeName eq 'int']
  in.nextInt()
[else if typeName eq 'long']
  in.nextLong()
[else if typeName eq 'float']
  (float) in.nextDouble()
[else if typeName eq 'double']
  in.nextDouble()
[else if typeName eq 'java.lang.String']
  in.nextString()
[else if typeName eq 'char']
  requireChar(in.nextString())
[else]
  requireChar("assertion")
  [output.error]assertion[/output.error]
[/if]
[/output.trim][/template]

[template constructorAcceptType Attribute a][output.trim]
[if a.typeKind.isMultimapKind]
  [guava].collect.Multimap<[a.elementType]>
[else if a.typeKind.isMapKind]
  java.util.Map<[a.elementType], [a.secondaryElementType]>
[else if a.typeKind.isCollectionKind]
  Iterable<[a.elementType]>
[else]
  [a.type]
[/if]
[/output.trim][/template]

[template guava]co['m.google.com']mon[/template][-- this is to hide from jar shading/class relocation in string constants --]
