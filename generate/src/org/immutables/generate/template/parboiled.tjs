[requirejs support('org/immutables/generate/template/support.js')]
[require immutable('org/immutables/generate/template/immutable.tjs')]

[template generateParboiled(type)]
[if (type.packageName)]
package `type.packageName`;
[/if]

import org.immutables.modeling.templating.parse.Extractions; 

// Generated imports

@SuppressWarnings("all")
@javax.annotation.ParametersAreNonnullByDefault
@javax.annotation.Generated({"parboiled.tjs", "`type.name`"})
`type.accessPrefix`final class Parboiled`type.simpleName` {
  private Parboiled`type.simpleName`() {
  }
[foreach (let v in type.nestedChildren)]
  [apply generateParboiledType(v)]
[/foreach]
}
[/template]

[template generateParboiledType(type)]

@Generated({"parboiled.tjs", "`type.name`"})
public static class `type.simpleName` {
  private `type.simpleName`() {}
[if(type.useSingleton || (type.useConstructor && type.constructorArguments.length == 0))]
  
  public static Extractions.Extractor<`type.name`> of() {
    return new Extractions.Instance() {
      @Override
      public `type.name` get() {
        return `type.immutableReferenceName`.of();
      }
      @Override
      public String toString() {
        return "`type.simpleName`.of()";
      } 
    };
  }
[/if]
[if(type.useConstructor && type.constructorArguments.length == 1)]
  [foreach(let c in type.constructorArguments)]
  [if (c.type == 'java.lang.String')]
  
  public static Extractions.Extractor<`type.name`> of() {
    return of(Extractions.matched());
  }
  [/if]
  
  public static Extractions.Extractor<`type.name`> of(Extractions.Extractor<`c.wrapperType`> `c.name`) {
    return new Extractions.Construct<`type.name`, `c.wrapperType`>(`c.name`) {
      @Override
      public `type.name` get(`c.wrapperType` value) {
        return `type.immutableReferenceName`.of(value);
      }
      @Override
      public String toString() {
        return "`type.simpleName`.of()";
      }
    };
  }
  [/foreach]
[/if]
[if(type.useBuilder)]

  public static Extractions.Applicator builder() {
    return new Extractions.Builder<`type.immutableReferenceName`.Builder>() {
      @Override
      public `type.immutableReferenceName`.Builder builder() {
        return `type.immutableReferenceName`.builder();
      }
      @Override
      public String toString() {
        return "`type.simpleName`.builder()";
      }
    };
  }
  
  public static Extractions.Extractor<`type.name`> build() {
    return new Extractions.Build<`type.immutableReferenceName`.Builder, `type.name`>() {
      @Override
      public `type.name` build(`type.immutableReferenceName`.Builder builder) {
        return builder.build();
      }
      @Override
      public String toString() {
        return "`type.simpleName`.build()";
      }
    };
  }
  [foreach (let a in type.implementedAttributes)]
  [if (a.collectionType)]
  
  public static Extractions.Applicator add`a.name.toUpperFirst()`() {
    return add`a.name.toUpperFirst()`(Extractions.<`a.wrappedElementType`>popped());
  }
  
  public static Extractions.Applicator add`a.name.toUpperFirst()`(Extractions.Extractor<? extends `a.wrappedElementType`> `a.name`Element) {
    return new Extractions.Specify<`type.immutableReferenceName`.Builder, `a.wrappedElementType`>(`a.name`Element) {
      @Override
      public void specify(`type.immutableReferenceName`.Builder builder, `a.wrappedElementType` value) {
        builder.add`a.name.toUpperFirst()`(value);
      }
      @Override
      public String toString() {
        return "`type.simpleName`.add`a.name.toUpperFirst()`()";
      }
    };
  }
  [elseif (a.mapType)]
  [elseif (a.optionalType)]
  
  public static Extractions.Applicator `a.name`() {
    return `a.name`(Extractions.<`a.wrappedElementType`>popped());
  }

  public static Extractions.Applicator `a.name`(Extractions.Extractor<? extends `a.wrappedElementType`> `a.name`) {
    return new Extractions.Specify<`type.immutableReferenceName`.Builder, `a.wrappedElementType`>(`a.name`) {
      @Override
      public void specify(`type.immutableReferenceName`.Builder builder, `a.wrappedElementType` value) {
        builder.`a.name`(value);
      }
      @Override
      public String toString() {
        return "`type.simpleName`.`a.name`()";
      }
    };
  }
  [else]
  
  public static Extractions.Applicator `a.name`() {
    return `a.name`(Extractions.<`a.wrapperType`>popped());
  }  

  public static Extractions.Applicator `a.name`(Extractions.Extractor<`a.wrapperType`> `a.name`) {
    return new Extractions.Specify<`type.immutableReferenceName`.Builder, `a.wrapperType`>(`a.name`) {
      @Override
      public void specify(`type.immutableReferenceName`.Builder builder, `a.wrapperType` value) {
        builder.`a.name`(value);
      }
      @Override
      public String toString() {
        return "`type.simpleName`.`a.name`()";
      }
    };
  }
  [/if]
  [/foreach]
[/if]
}
[/template]
