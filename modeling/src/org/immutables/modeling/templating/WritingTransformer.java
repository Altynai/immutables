package org.immutables.modeling.templating;

import com.google.common.base.Supplier;
import com.google.common.collect.ImmutableList;
import java.util.List;
import javax.lang.model.element.TypeElement;
import org.immutables.modeling.Intrinsics;
import org.immutables.modeling.Templates;
import org.immutables.modeling.introspect.Accessors.BoundAccess;
import org.immutables.modeling.introspect.SwissArmyKnife;
import org.immutables.modeling.templating.ImmutableTrees.ApplyExpression;
import org.immutables.modeling.templating.ImmutableTrees.AssignGenerator;
import org.immutables.modeling.templating.ImmutableTrees.Block;
import org.immutables.modeling.templating.ImmutableTrees.BoundAccessExpression;
import org.immutables.modeling.templating.ImmutableTrees.ConditionalBlock;
import org.immutables.modeling.templating.ImmutableTrees.ForStatement;
import org.immutables.modeling.templating.ImmutableTrees.IfStatement;
import org.immutables.modeling.templating.ImmutableTrees.InvokableDeclaration;
import org.immutables.modeling.templating.ImmutableTrees.InvokeStatement;
import org.immutables.modeling.templating.ImmutableTrees.IterationGenerator;
import org.immutables.modeling.templating.ImmutableTrees.LetStatement;
import org.immutables.modeling.templating.ImmutableTrees.ResolvedType;
import org.immutables.modeling.templating.ImmutableTrees.Template;
import org.immutables.modeling.templating.ImmutableTrees.TextBlock;
import org.immutables.modeling.templating.ImmutableTrees.Unit;
import org.immutables.modeling.templating.ImmutableTrees.ValueDeclaration;
import org.immutables.modeling.templating.Trees.Expression;
import org.immutables.modeling.templating.Trees.TextPart;
import static org.immutables.modeling.common.StringLiterals.*;

/**
 * This part is written with simples possible writer in mind. It was decided not to use dependencies
 * like. Its is possible that in future it will be replaced with self bootstraping, i.e. template
 * generator will be generated by the same framework which generates templates.
 */
public final class WritingTransformer extends TreesTransformer<WritingTransformer.Context> {
  private final TypeElement sourceElement;
  private final String simpleName;
  private final SwissArmyKnife knife;

  public WritingTransformer(SwissArmyKnife knife, TypeElement sourceElement, String simpleName) {
    this.knife = knife;
    this.sourceElement = sourceElement;
    this.simpleName = simpleName;
  }

  public CharSequence toCharSequence(Unit unit) {
    Context context = new Context();
    transform(context, unit);
    return context.builder;
  }

  @Override
  public Unit transform(Context context, Unit value) {
    context.out("package ")
        .out(knife.elements.getPackageOf(sourceElement).getQualifiedName())
        .out(";")
        .ln()
        .ln()
        .out("import static ")
        .out(Intrinsics.class)
        .out(".*;")
        .ln()
        .ln();

    context
        .out("@").out(SuppressWarnings.class)
        .out("(")
        .out(toLiteral("unused"))
        .out(")")
        .ln()
        .out("public class ")
        .out(simpleName)
        .out(" extends ")
        .out(sourceElement.getQualifiedName())
        .out(" {")
        .ln();

    Unit unit = super.transform(context, value);

    context
        .ln()
        .out('}')
        .ln();

    return unit;
  }

  @Override
  public Template transform(final Context context, final Template value) {
    String name = value.declaration().name().value();

    context
        .ln()
        .out(Templates.Invokable.class)
        .out(" ")
        .out(name)
        .out("() { return ")
        .out(name)
        .out("; }").ln();

    context.out("private ");

    return generateTemplateLike(context, value.declaration(), new Supplier<Template>() {
      @Override
      public Template get() {
        return WritingTransformer.super.transform(context, value);
      }
    });
  }

  private <T> T generateTemplateLike(Context context, Trees.InvokableDeclaration declaration, Supplier<T> supplier) {
    context.out("final ")
        .out(Templates.Invokable.class)
        .out(" ")
        .out(declaration.name().value())
        .out(" = ")
        .out("new ")
        .out(Templates.Fragment.class)
        .out("(", declaration.parameters().size(), ") ")
        .openBrace()
        .ln()
        .out("@Override public void run(").out(Templates.Invokation.class).out(" __) ")
        .openBrace()
        .indent()
        .ln();

    int braces = context.getAndSetPendingBraces(0);

    T result = supplier.get();

    context.getAndSetPendingBraces(braces);
    context.outdent().ln().closeBraces().out(";");
    return result;
  }

  @Override
  public LetStatement transform(final Context context, final LetStatement statement) {
    return generateTemplateLike(context, statement.declaration(), new Supplier<LetStatement>() {
      @Override
      public LetStatement get() {
        context.out("final ")
            .out(Templates.Invokable.class)
            .out(" ")
            .out(statement.declaration().name().value())
            .out(" = this;")
            .ln();
        return WritingTransformer.super.transform(context, statement);
      }
    });
  }

  @Override
  public ForStatement transform(Context context, ForStatement statement) {
    context.openBrace();

    transformForStatementDeclaration(context, statement, statement.declaration());

    int braces = context.getAndSetPendingBraces(0);
    context.indent();
    context.infor()
        .out("final ")
        .out(Templates.Iteration.class)
        .out(" ")
        .out(context.accessMapper(Resolver.ITERATION_ACCESS_VARIABLE))
        .out(" = new ")
        .out(Templates.Iteration.class)
        .out("();")
        .ln();

    transformForStatementParts(context, statement, statement.parts());

    context.out(context.accessMapper(Resolver.ITERATION_ACCESS_VARIABLE)).out(".index++;").ln();
    context.out(context.accessMapper(Resolver.ITERATION_ACCESS_VARIABLE)).out(".first = false;").ln();
    context.outfor();
    context.getAndSetPendingBraces(braces);
    context.outdent().ln()
        .closeBraces().ln();

    return statement;
  }

  @Override
  public InvokeStatement transform(Context context, InvokeStatement statement) {

    context.out("$(__, ");
    transformInvokeStatementAccess(context, statement, statement.access());
    transformInvokeStatementParams(context, statement, statement.params());

    if (!statement.parts().isEmpty()) {
      context.out(", new ")
          .out(Templates.Fragment.class)
          .out("() ")
          .openBrace()
          .ln()
          .out("@Override public void run(")
          .out(Templates.Invokation.class).out(" __) ")
          .openBrace();

      int braces = context.getAndSetPendingBraces(0);
      context.indent().ln();

      transformInvokeStatementParts(context, statement, statement.parts());

      context.getAndSetPendingBraces(braces);
      context.outdent().ln()
          .closeBraces().ln();
    }

    context.out(");");

    return statement;
  }

  @Override
  protected Iterable<Expression> transformInvokeStatementParams(
      Context context,
      InvokeStatement value,
      List<Expression> collection) {
    for (Trees.Expression element : collection) {
      context.out(", ");
      transformInvokeStatementParamsElement(context, value, element);
    }
    return collection;
  }

  @Override
  public AssignGenerator transform(Context context, AssignGenerator generator) {
    transformAssignGeneratorDeclaration(context, generator, generator.declaration());
    context.out(" = $(");
    transformAssignGeneratorFrom(context, generator, generator.from());
    context.out(");").ln();
    return generator;
  }

  @Override
  public IterationGenerator transform(Context context, IterationGenerator generator) {
    context.out("for (");
    transformIterationGeneratorDeclaration(context, generator, generator.declaration());
    context.out(" : $in(");
    transformIterationGeneratorFrom(context, generator, generator.from());
    context.out(")) ").openBrace().ln();

    if (generator.condition().isPresent()) {
      context.out("if ($if(");
      transformIterationGeneratorCondition(context, generator, generator.condition());
      context.out(")) ").openBrace().ln();
    }

    return generator;
  }

  @Override
  public ValueDeclaration transform(
      Context context,
      ValueDeclaration value) {
    ResolvedType resolvedType = (ResolvedType) value.type().get();
    context.out("final ").out(resolvedType.type()).out(" ").out(value.name().value());
    return value;
  }

  @Override
  public TextBlock transform(Context context, TextBlock block) {
    boolean lineStarted = false;
    for (TextPart textPart : block.parts()) {
      if (textPart instanceof Trees.Newline) {
        context.out(lineStarted ? ").ln();" : "__.ln();").ln();
        lineStarted = false;
      } else if (!textPart.toString().equals("\"\"")) {
        context.out(lineStarted ? ", " : "__.out(").out(textPart);
        lineStarted = true;
      }
    }
    if (lineStarted) {
      context.out(");").ln();
    }

    return block;
  }

  @Override
  public BoundAccessExpression transform(Context context, BoundAccessExpression value) {
    ImmutableList<BoundAccess> accessList = Resolver.asBoundAccess(value.accessor());

    StringBuilder expressionBuilder = new StringBuilder();

    for (int i = 0; i < accessList.size(); i++) {
      boolean first = i == 0;
      boolean last = i != accessList.size() - 1;

      BoundAccess access = accessList.get(i);

      if (!first) {
        expressionBuilder.append(".");
      }

      String name = access.name;

      if (first) {
        name = context.accessMapper(name);
      }

      expressionBuilder.append(name).append(access.callable ? "()" : "");

      if (access.boxed && last) {
        expressionBuilder.insert(0, "$(");
        expressionBuilder.append(")");
      }
    }

    context.out(expressionBuilder);

    return value;
  }

  @Override
  public ApplyExpression transform(Context context, ApplyExpression value) {
    context.out("$(");
    ApplyExpression expression = super.transform(context, value);
    context.out(")");
    return expression;
  }

  @Override
  protected Iterable<Expression> transformApplyExpressionParams(
      Context context,
      ApplyExpression value,
      List<Expression> collection) {
    boolean first = true;
    for (Trees.Expression element : collection) {
      if (!first) {
        context.out(", ");
      }
      first = false;
      transformApplyExpressionParamsElement(context, value, element);
    }
    return collection;
  }

  private void writeConditionPart(Context context, ConditionalBlock block) {
    context.out("if ($if(");

    transformConditionalBlockCondition(context, block, block.condition());

    context.out(")) {")
        .indent()
        .ln();

    transformConditionalBlockParts(context, block, block.parts());
  }

  @Override
  public IfStatement transform(Context context, IfStatement statement) {

    writeConditionPart(context, (ConditionalBlock) statement.then());

    for (Trees.ConditionalBlock block : statement.otherwiseIf()) {
      context.outdent().out("} else ");

      writeConditionPart(context, (ConditionalBlock) block);
    }

    if (statement.otherwise().isPresent()) {
      context.outdent()
          .ln()
          .out("} else {")
          .indent()
          .ln();

      transform(context, (Block) statement.otherwise().get());
    }

    context.outdent()
        .ln()
        .out("}");

    return statement;
  }

  @Override
  public InvokableDeclaration transform(Context context, InvokableDeclaration value) {
    int count = 0;

    for (Trees.Parameter parameter : value.parameters()) {
      context.out("final ", parameter.type(), " ", parameter.name().value())
          .out(" = (", parameter.type(), ") __.param(", count++, ");").ln();
    }

    return super.transform(context, value);
  }

  static class Context {
    final StringBuilder builder = new StringBuilder();
    private int indentLevel;
    private int bracesToClose;
    private int forLevels;

    Context infor() {
      forLevels++;
      return this;
    }

    Context outfor() {
      forLevels--;
      return this;
    }

    Context indent() {
      indentLevel++;
      return this;
    }

    Context outdent() {
      indentLevel--;
      return this;
    }

    Context out(Object... objects) {
      for (Object object : objects) {
        out(object);
      }
      return this;
    }

    public String accessMapper(String identifer) {
      if (Resolver.ITERATION_ACCESS_VARIABLE.equals(identifer)) {
        return "_it" + forLevels;
      }
      return identifer;
    }

    int getAndSetPendingBraces(int bracesToClose) {
      int value = this.bracesToClose;
      this.bracesToClose = bracesToClose;
      return value;
    }

    Context closeBraces() {
      for (int i = 0; i < bracesToClose; i++) {
        builder.append('}');
      }
      bracesToClose = 0;
      return this;
    }

    Context openBrace() {
      builder.append('{');
      bracesToClose++;
      return this;
    }

    Context out(Object object) {
      if (object instanceof Class<?>) {
        object = ((Class<?>) object).getCanonicalName();
      }
      if (object instanceof CharSequence) {
        builder.append((CharSequence) object);
        return this;
      }
      builder.append(object.toString());
      return this;
    }

    Context ln() {
      builder.append('\n');
      for (int i = 0; i < indentLevel; i++) {
        builder.append("  ");
      }
      return this;
    }
  }
}
